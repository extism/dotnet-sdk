{
  "README.html": {
    "href": "README.html",
    "title": "Extism .NET Host SDK | Extism .NET SDK",
    "summary": "Extism .NET Host SDK This repo houses the .NET SDK for integrating with the Extism runtime. Install this library into your host .NET applications to run Extism plugins. Installation This library depends on the native Extism runtime, we provide native runtime packages for all supported operating systems. You can install with: dotnet add package Extism.runtime.all Then, add the Extism.Sdk NuGet package to your project: dotnet add package Extism.Sdk PowerShell Open a PowerShell console and detect the Common Language Runtime (CLR) major version with the command [System.Environment]::Version Download the Extism.Sdk NuGet package and change the extension from nupkg to zip. Open the zip file and go into the lib folder. Choose the net folder in dependency of the CLR major version and open it. Copy the file Extism.sdk.dll in your PowerShell script directory. Download the Extism native runtime package in dependency of your operating system and change the extension from nupkg to zip. Open the zip file and go into the runtimes folder. At the end of the path you will find a file with the name libextism.so (shared object) or extism.dll (dynamic link library). Copy this file in your PowerShell script directory. Getting Started This guide should walk you through some of the concepts in Extism and this .NET library. First you should add a using statement for Extism: C#: using System; using Extism.Sdk; F#: open System open Extism.Sdk PowerShell [System.String]$LibDir = $($PSScriptRoot) [System.String]$Extism = $($LibDir) + \"/Extism.Sdk.dll\" Add-Type -Path $Extism Creating A Plug-in The primary concept in Extism is the plug-in. You can think of a plug-in as a code module stored in a .wasm file. Since you may not have an Extism plug-in on hand to test, let's load a demo plug-in from the web: C#: var manifest = new Manifest(new UrlWasmSource(\"https://github.com/extism/plugins/releases/latest/download/count_vowels.wasm\")); using var plugin = new Plugin(manifest, new HostFunction[] { }, withWasi: true); F#: let uri = Uri(\"https://github.com/extism/plugins/releases/latest/download/count_vowels.wasm\") let manifest = Manifest(new UrlWasmSource(uri)) let plugin = new Plugin(manifest, Array.Empty<HostFunction>(), withWasi = true) PowerShell: $Manifest = [Extism.Sdk.Manifest]::new( [Extism.Sdk.UrlWasmSource]::new( \"https://github.com/extism/plugins/releases/latest/download/count_vowels.wasm\" ) ) $HostFunctionArray = [Extism.Sdk.HostFunction[]]::new(0) $Options = [Extism.Sdk.PluginIntializationOptions]::new() $Options.WithWasi = $True $Plugin = [Extism.Sdk.Plugin]::new($Manifest, $HostFunctionArray, $Options) Note: The schema for this manifest can be found here: https://extism.org/docs/concepts/manifest/ Calling A Plug-in's Exports This plug-in was written in Rust and it does one thing, it counts vowels in a string. As such, it exposes one \"export\" function: count_vowels. We can call exports using Plugin.Call: C#: var output = plugin.Call(\"count_vowels\", \"Hello, World!\"); Console.WriteLine(output); // => {\"count\": 3, \"total\": 3, \"vowels\": \"aeiouAEIOU\"} F#: let output = plugin.Call(\"count_vowels\", \"Hello, World!\") printfn \"%s\" output // => {\"count\": 3, \"total\": 3, \"vowels\": \"aeiouAEIOU\"} PowerShell: $output = $Plugin.Call(\"count_vowels\", \"Hello, World!\") Write-Host $output # => {\"count\": 3, \"total\": 3, \"vowels\": \"aeiouAEIOU\"} All exports have a simple interface of optional bytes in, and optional bytes out. This plug-in happens to take a string and return a JSON encoded string with a report of results. Precompiling plugins If you're going to create more than one instance of the same plugin, we recommend pre-compiling the plugin and instantiate them: C#: var manifest = new Manifest(new PathWasmSource(\"/path/to/plugin.wasm\"), \"main\")); // pre-compile the wasm file using var compiledPlugin = new CompiledPlugin(_manifest, [], withWasi: true); // instantiate plugins using var plugin = compiledPlugin.Instantiate(); F#: // Create manifest let manifest = Manifest(PathWasmSource(\"/path/to/plugin.wasm\")) // Pre-compile the wasm file use compiledPlugin = new CompiledPlugin(manifest, Array.empty<HostFunction>, withWasi = true) // Instantiate plugins use plugin = compiledPlugin.Instantiate() This can have a dramatic effect on performance*: // * Summary * BenchmarkDotNet v0.14.0, Windows 11 (10.0.22631.4460/23H2/2023Update/SunValley3) 13th Gen Intel Core i7-1365U, 1 CPU, 12 logical and 10 physical cores .NET SDK 9.0.100 [Host] : .NET 9.0.0 (9.0.24.52809), X64 RyuJIT AVX2 DefaultJob : .NET 9.0.0 (9.0.24.52809), X64 RyuJIT AVX2 | Method | Mean | Error | StdDev | |-------------------------- |------------:|----------:|------------:| | CompiledPluginInstantiate | 266.2 ms | 6.66 ms | 19.11 ms | | PluginInstantiate | 27,592.4 ms | 635.90 ms | 1,783.12 ms | *: See the complete benchmark Plug-in State Plug-ins may be stateful or stateless. Plug-ins can maintain state b/w calls by the use of variables. Our count vowels plug-in remembers the total number of vowels it's ever counted in the \"total\" key in the result. You can see this by making subsequent calls to the export: C#: var output = plugin.Call(\"count_vowels\", \"Hello, World!\"); Console.WriteLine(output); // => {\"count\": 3, \"total\": 6, \"vowels\": \"aeiouAEIOU\"} output = plugin.Call(\"count_vowels\", \"Hello, World!\"); Console.WriteLine(output); // => {\"count\": 3, \"total\": 9, \"vowels\": \"aeiouAEIOU\"} F#: let output1 = plugin.Call(\"count_vowels\", \"Hello, World!\") printfn \"%s\" output1 // => {\"count\": 3, \"total\": 6, \"vowels\": \"aeiouAEIOU\"} let output2 = plugin.Call(\"count_vowels\", \"Hello, World!\") printfn \"%s\" output2 // => {\"count\": 3, \"total\": 9, \"vowels\": \"aeiouAEIOU\"} These variables will persist until this plug-in is freed or you initialize a new one. Configuration Plug-ins may optionally take a configuration object. This is a static way to configure the plug-in. Our count-vowels plugin takes an optional configuration to change out which characters are considered vowels. Example: C#: var manifest = new Manifest(new UrlWasmSource(\"<https://github.com/extism/plugins/releases/latest/download/count_vowels.wasm>\")); using var plugin = new Plugin(manifest, new HostFunction[] { }, withWasi: true); var output = plugin.Call(\"count_vowels\", \"Yellow, World!\"); Console.WriteLine(output); // => {\"count\": 3, \"total\": 3, \"vowels\": \"aeiouAEIOU\"} manifest = new Manifest(new UrlWasmSource(\"<https://github.com/extism/plugins/releases/latest/download/count_vowels.wasm>\")) { Config = new Dictionary<string, string> { { \"vowels\", \"aeiouyAEIOUY\" } }, }; using var plugin2 = new Plugin(manifest, new HostFunction[] { }, withWasi: true); var output2 = plugin2.Call(\"count_vowels\", \"Yellow, World!\"); Console.WriteLine(output2); // => {\"count\": 4, \"total\": 4, \"vowels\": \"aeiouAEIOUY\"} F#: let uri = Uri(\"https://github.com/extism/plugins/releases/latest/download/count_vowels.wasm\") let manifest = Manifest(new UrlWasmSource(uri)) manifest.Config <- dict [(\"vowels\", \"aeiouAEIOU\")] let plugin = new Plugin(manifest, Array.Empty<HostFunction>(), withWasi = true) let output = plugin.Call(\"count_vowels\", \"Yellow, World!\") Console.WriteLine(output) // => {\"count\": 3, \"total\": 3, \"vowels\": \"aeiouAEIOU\"} let manifest2 = Manifest(new UrlWasmSource(Uri(\"https://github.com/extism/plugins/releases/latest/download/count_vowels.wasm\"))) manifest2.Config <- dict [(\"vowels\", \"aeiouyAEIOUY\")] let plugin2 = new Plugin(manifest2, Array.Empty<HostFunction>(), withWasi = true) let output2 = plugin2.Call(\"count_vowels\", \"Yellow, World!\") printfn \"%s\" output2 // => {\"count\": 4, \"total\": 4, \"vowels\": \"aeiouAEIOUY\"} Host Functions Let's extend our count-vowels example a little bit: Instead of storing the total in an ephemeral plug-in var, let's store it in a persistent key-value store! Wasm can't use our KV store on it's own. This is where Host Functions come in. Host functions allow us to grant new capabilities to our plug-ins from our application. They are simply some Go functions you write which can be passed down and invoked from any language inside the plug-in. Let's load the manifest like usual but load up this count_vowels_kvstore plug-in: C#: var manifest = new Manifest(new UrlWasmSource(\"https://github.com/extism/plugins/releases/latest/download/count_vowels_kvstore.wasm\")); F#: let manifest = Manifest(new UrlWasmSource(Uri(\"https://github.com/extism/plugins/releases/latest/download/count_vowels_kvstore.wasm\"))) Note: The source code for this is here and is written in rust, but it could be written in any of our PDK languages. Unlike our previous plug-in, this plug-in expects you to provide host functions that satisfy our its import interface for a KV store. We want to expose two functions to our plugin, void kv_write(key string, value byte[]) which writes a bytes value to a key and byte[] kv_read(key string) which reads the bytes at the given key. C#: // pretend this is Redis or something :) var kvStore = new Dictionary<string, byte[]>(); var functions = new[] { HostFunction.FromMethod(\"kv_read\", null, (CurrentPlugin plugin, long keyOffset) => { var key = plugin.ReadString(keyOffset); if (!kvStore.TryGetValue(key, out var value)) { value = new byte[] { 0, 0, 0, 0 }; } Console.WriteLine($\"Read {BitConverter.ToUInt32(value)} from key={key}\"); return plugin.WriteBytes(value); }), HostFunction.FromMethod(\"kv_write\", null, (CurrentPlugin plugin, long keyOffset, long valueOffset) => { var key = plugin.ReadString(keyOffset); var value = plugin.ReadBytes(valueOffset); Console.WriteLine($\"Writing value={BitConverter.ToUInt32(value)} from key={key}\"); kvStore[key] = value.ToArray(); }) }; F#: let kvStore = new Dictionary<string, byte[]>() let functions = [| HostFunction.FromMethod(\"kv_read\", null, fun (plugin: CurrentPlugin) (offs: int64) -> let key = plugin.ReadString(offs) let value = match kvStore.TryGetValue(key) with | true, v -> v | _ -> [| 0uy; 0uy; 0uy; 0uy |] // Default value if key not found Console.WriteLine($\"Read {BitConverter.ToUInt32(value, 0)} from key={key}\") plugin.WriteBytes(value) ) HostFunction.FromMethod(\"kv_write\", null, fun (plugin: CurrentPlugin) (kOffs: int64) (vOffs: int64) -> let key = plugin.ReadString(kOffs) let value = plugin.ReadBytes(vOffs).ToArray() Console.WriteLine($\"Writing value={BitConverter.ToUInt32(value, 0)} from key={key}\") kvStore.[key] <- value ) |] Note: In order to write host functions you should get familiar with the methods on the CurrentPlugin type. The plugin parameter is an instance of this type. We need to pass these imports to the plug-in to create them. All imports of a plug-in must be satisfied for it to be initialized: C#: using var plugin = new Plugin(manifest, functions, withWasi: true); var output = plugin.Call(\"count_vowels\", \"Hello World!\"); Console.WriteLine(output); // => Read 0 from key=count-vowels\" // => Writing value=3 from key=count-vowels\" // => {\"count\": 3, \"total\": 3, \"vowels\": \"aeiouAEIOU\"} output = plugin.Call(\"count_vowels\", \"Hello World!\"); Console.WriteLine(output); // => Read 3 from key=count-vowels\" // => Writing value=6 from key=count-vowels\" // => {\"count\": 3, \"total\": 6, \"vowels\": \"aeiouAEIOU\"} F#: let plugin = new Plugin(manifest, functions, withWasi = true) let output = plugin.Call(\"count_vowels\", \"Hello World!\") printfn \"%s\" output // => Read 0 from key=count-vowels // => Writing value=3 from key=count-vowels // => {\"count\": 3, \"total\": 3, \"vowels\": \"aeiouAEIOU\"} let output2 = plugin.Call(\"count_vowels\", \"Hello World!\") printfn \"%s\" output2 // => Read 3 from key=count-vowels // => Writing value=6 from key=count-vowels // => {\"count\": 3, \"total\": 6, \"vowels\": \"aeiouAEIOU\"} Passing context to host functions Extism provides two ways to pass context to host functions: UserData UserData allows you to associate persistent state with a host function that remains available across all calls to that function. This is useful for maintaining configuration or state that should be available throughout the lifetime of the host function. C#: var hostFunc = new HostFunction( \"hello_world\", new[] { ExtismValType.PTR }, new[] { ExtismValType.PTR }, \"Hello again!\", // <= userData, this can be any .NET object (CurrentPlugin plugin, Span<ExtismVal> inputs, Span<ExtismVal> outputs) => { var text = plugin.GetUserData<string>(); // <= We're retrieving the data back // Use text... }); F#: // Create host function with userData let hostFunc = new HostFunction( \"hello_world\", [| ExtismValType.PTR |], [| ExtismValType.PTR |], \"Hello again!\", // userData can be any .NET object (fun (plugin: CurrentPlugin) (inputs: Span<ExtismVal>) (outputs: Span<ExtismVal>) -> // Retrieve the userData let text = plugin.GetUserData<string>() printfn \"%s\" text // Prints: \"Hello again!\" // Rest of function implementation... )) The userData object is preserved for the lifetime of the host function and can be retrieved in any call using CurrentPlugin.GetUserData<T>(). If no userData was provided, GetUserData<T>() will return the default value for type T. Call Host Context Call Host Context provides a way to pass per-call context data when invoking a plugin function. This is useful when you need to provide data specific to a particular function call rather than data that persists across all calls. C#: // Pass context for specific call var context = new Dictionary<string, object> { { \"requestId\", 42 } }; var result = plugin.CallWithHostContext(\"function_name\", inputData, context); // Access in host function void HostFunction(CurrentPlugin plugin, Span<ExtismVal> inputs, Span<ExtismVal> outputs) { var context = plugin.GetCallHostContext<Dictionary<string, object>>(); // Use context... } F#: // Create context for specific call let context = dict [ \"requestId\", box 42 ] // Call plugin with context let result = plugin.CallWithHostContext(\"function_name\", inputData, context) // Access context in host function let hostFunction (plugin: CurrentPlugin) (inputs: Span<ExtismVal>) (outputs: Span<ExtismVal>) = match plugin.GetCallHostContext<IDictionary<string, obj>>() with | null -> printfn \"No context available\" | context -> let requestId = context.[\"requestId\"] :?> int printfn \"Request ID: %d\" requestId Host context is only available for the duration of the specific function call and can be retrieved using CurrentPlugin.GetHostContext<T>(). If no context was provided for the call, GetHostContext<T>() will return the default value for type T. Fuel limit The fuel limit feature allows you to constrain plugin execution by limiting the number of instructions it can execute. This provides a safeguard against infinite loops or excessive resource consumption. Setting a fuel limit Set the fuel limit when initializing a plugin: C#: var manifest = new Manifest(...); var options = new PluginIntializationOptions { FuelLimit = 1000, // plugin can execute 1000 instructions WithWasi = true }; var plugin = new Plugin(manifest, functions, options); F#: let manifest = Manifest(PathWasmSource(\"/path/to/plugin.wasm\")) let options = PluginIntializationOptions( FuelLimit = Nullable<int64>(1000L), // plugin can execute 1000 instructions WithWasi = true ) use plugin = new Plugin(manifest, Array.empty<HostFunction>, options) When the fuel limit is exceeded, the plugin execution is terminated and an ExtismException is thrown containing \"fuel\" in the error message."
  },
  "api/Extism.Sdk.ByteArrayWasmSource.html": {
    "href": "api/Extism.Sdk.ByteArrayWasmSource.html",
    "title": "Class ByteArrayWasmSource | Extism .NET SDK",
    "summary": "Class ByteArrayWasmSource Namespace Extism.Sdk Assembly Extism.Sdk.dll Wasm Source represented by raw bytes. public class ByteArrayWasmSource : WasmSource Inheritance object WasmSource ByteArrayWasmSource Inherited Members WasmSource.Name WasmSource.Hash object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ByteArrayWasmSource(byte[], string?, string?) Constructor public ByteArrayWasmSource(byte[] data, string? name, string? hash = null) Parameters data byte[] the byte array representing the Wasm code name string hash string Properties Data The byte array representing the Wasm code [JsonPropertyName(\"data\")] public byte[] Data { get; } Property Value byte[]"
  },
  "api/Extism.Sdk.CompiledPlugin.html": {
    "href": "api/Extism.Sdk.CompiledPlugin.html",
    "title": "Class CompiledPlugin | Extism .NET SDK",
    "summary": "Class CompiledPlugin Namespace Extism.Sdk Assembly Extism.Sdk.dll A pre-compiled plugin ready to be instantiated. public class CompiledPlugin : IDisposable Inheritance object CompiledPlugin Implements IDisposable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors CompiledPlugin(Manifest, HostFunction[], bool) Compile a plugin from a Manifest. public CompiledPlugin(Manifest manifest, HostFunction[] functions, bool withWasi) Parameters manifest Manifest functions HostFunction[] withWasi bool Methods CheckNotDisposed() Throw an appropriate exception if the plugin has been disposed. protected void CheckNotDisposed() Exceptions ObjectDisposedException Dispose() Frees all resources held by this Plugin. public void Dispose() Dispose(bool) Frees all resources held by this Plugin. protected virtual void Dispose(bool disposing) Parameters disposing bool ~CompiledPlugin() Destructs the current Plugin and frees all resources used by it. protected ~CompiledPlugin() Instantiate() Instantiate a plugin from this compiled plugin. public Plugin Instantiate() Returns Plugin"
  },
  "api/Extism.Sdk.CurrentPlugin.html": {
    "href": "api/Extism.Sdk.CurrentPlugin.html",
    "title": "Class CurrentPlugin | Extism .NET SDK",
    "summary": "Class CurrentPlugin Namespace Extism.Sdk Assembly Extism.Sdk.dll Represents the current plugin. Can only be used within HostFunctions. public class CurrentPlugin Inheritance object CurrentPlugin Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties UserData Returns the user data object that was passed in when a HostFunction was registered. [Obsolete(\"Use GetUserData<T> instead.\")] public nint UserData { get; } Property Value nint Methods AllocateBlock(long) Allocate a memory block in the currently running plugin. public long AllocateBlock(long length) Parameters length long Returns long BlockLength(long) Get the length of an allocated block. NOTE: this should only be called from host functions. public long BlockLength(long offset) Parameters offset long Returns long FreeBlock(long) Frees a block of memory belonging to the current plugin. public void FreeBlock(long offset) Parameters offset long GetCallHostContext<T>() Get the current plugin call's associated host context data. Returns null if call was made without host context. public T? GetCallHostContext<T>() Returns T Type Parameters T GetMemory() Returns a offset to the memory of the currently running plugin. NOTE: this should only be called from host functions. public long GetMemory() Returns long GetUserData<T>() Returns the user data object that was passed in when a HostFunction was registered. public T? GetUserData<T>() Returns T Type Parameters T ReadBytes(long) Returns a span of bytes for a given block. public Span<byte> ReadBytes(long offset) Parameters offset long Returns Span<byte> ReadString(long) Reads a string from a memory block using UTF8. public string ReadString(long offset) Parameters offset long Returns string ReadString(long, Encoding) Reads a string form a memory block. public string ReadString(long offset, Encoding encoding) Parameters offset long encoding Encoding Returns string WriteBytes(long, Span<byte>) Writes a byte array into a block of memory. public void WriteBytes(long offset, Span<byte> bytes) Parameters offset long bytes Span<byte> WriteBytes(Span<byte>) Writes a byte array into a newly allocated block of memory. public long WriteBytes(Span<byte> bytes) Parameters bytes Span<byte> Returns long Returns the offset of the allocated block WriteString(string) Writes a string into the current plugin memory using UTF-8 encoding and returns the offset of the block. public long WriteString(string value) Parameters value string Returns long WriteString(string, Encoding) Writes a string into the current plugin memory and returns the offset of the block. public long WriteString(string value, Encoding encoding) Parameters value string encoding Encoding Returns long"
  },
  "api/Extism.Sdk.ExtismException.html": {
    "href": "api/Extism.Sdk.ExtismException.html",
    "title": "Class ExtismException | Extism .NET SDK",
    "summary": "Class ExtismException Namespace Extism.Sdk Assembly Extism.Sdk.dll Represents errors that occur during calling Extism functions. public class ExtismException : Exception, ISerializable Inheritance object Exception ExtismException Implements ISerializable Inherited Members Exception.GetBaseException() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors ExtismException() Initializes a new instance of the ExtismException class. public ExtismException() ExtismException(string) Initializes a new instance of the ExtismException class with a specified error message. public ExtismException(string message) Parameters message string The message that describes the error . ExtismException(string, Exception) Initializes a new instance of the ExtismException class with a specified error message and a reference to the inner exception that is the cause of this exception. public ExtismException(string message, Exception innerException) Parameters message string The message that describes the error. innerException Exception The exception that is the cause of the current exception, or a null reference (Nothing in Visual Basic) if no inner exception is specified."
  },
  "api/Extism.Sdk.ExtismFunction.html": {
    "href": "api/Extism.Sdk.ExtismFunction.html",
    "title": "Delegate ExtismFunction | Extism .NET SDK",
    "summary": "Delegate ExtismFunction Namespace Extism.Sdk Assembly Extism.Sdk.dll A host function signature. public delegate void ExtismFunction(CurrentPlugin plugin, Span<ExtismVal> inputs, Span<ExtismVal> outputs) Parameters plugin CurrentPlugin Plugin Index inputs Span<ExtismVal> Input parameters outputs Span<ExtismVal> Output parameters, the host function can change this."
  },
  "api/Extism.Sdk.HostFunction.html": {
    "href": "api/Extism.Sdk.HostFunction.html",
    "title": "Class HostFunction | Extism .NET SDK",
    "summary": "Class HostFunction Namespace Extism.Sdk Assembly Extism.Sdk.dll A function provided by the host that plugins can call. public class HostFunction : IDisposable Inheritance object HostFunction Implements IDisposable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors HostFunction(string, Span<ExtismValType>, Span<ExtismValType>, object?, ExtismFunction) Registers a Host Function. public HostFunction(string functionName, Span<ExtismValType> inputTypes, Span<ExtismValType> outputTypes, object? userData, ExtismFunction hostFunction) Parameters functionName string The literal name of the function, how it would be called from a Plugin. inputTypes Span<ExtismValType> The types of the input arguments/parameters the Plugin caller will provide. outputTypes Span<ExtismValType> The types of the output returned from the host function to the Plugin. userData object A state object that will be preserved and can be retrieved during function execution using GetUserData<T>(). This allows you to maintain context between function calls. hostFunction ExtismFunction Methods CheckNotDisposed() Throw an appropriate exception if the Host Function has been disposed. protected void CheckNotDisposed() Exceptions ObjectDisposedException Dispose() Frees all resources held by this Host Function. public void Dispose() Dispose(bool) Frees all resources held by this Host Function. protected virtual void Dispose(bool disposing) Parameters disposing bool ~HostFunction() Destructs the current Host Function and frees all resources used by it. protected ~HostFunction() FromMethod(string, object, Action<CurrentPlugin>) Registers a HostFunction from a method that takes no parameters an returns no values. public static HostFunction FromMethod(string functionName, object userData, Action<CurrentPlugin> callback) Parameters functionName string The literal name of the function, how it would be called from a Plugin. userData object A state object that will be preserved and can be retrieved during function execution using GetUserData<T>(). This allows you to maintain context between function calls. callback Action<CurrentPlugin> The host function implementation. Returns HostFunction FromMethod<I1>(string, object, Action<CurrentPlugin, I1>) Registers a HostFunction from a method that takes 1 parameter an returns no values. Supported parameter types: int, uint, long, ulong, float, double public static HostFunction FromMethod<I1>(string functionName, object userData, Action<CurrentPlugin, I1> callback) where I1 : struct Parameters functionName string The literal name of the function, how it would be called from a Plugin. userData object A state object that will be preserved and can be retrieved during function execution using GetUserData<T>(). This allows you to maintain context between function calls. callback Action<CurrentPlugin, I1> The host function implementation. Returns HostFunction Type Parameters I1 Type of first parameter. Supported parameter types: int, uint, long, ulong, float, double FromMethod<R>(string, object, Func<CurrentPlugin, R>) Registers a HostFunction from a method that takes no parameters an returns a value. Supported return types: int, uint, long, ulong, float, double public static HostFunction FromMethod<R>(string functionName, object userData, Func<CurrentPlugin, R> callback) where R : struct Parameters functionName string The literal name of the function, how it would be called from a Plugin. userData object A state object that will be preserved and can be retrieved during function execution using GetUserData<T>(). This allows you to maintain context between function calls. callback Func<CurrentPlugin, R> The host function implementation. Returns HostFunction Type Parameters R Type of the first parameter. Supported parameter types: int, uint, long, ulong, float, double FromMethod<I1, I2>(string, object, Action<CurrentPlugin, I1, I2>) Registers a HostFunction from a method that takes 2 parameters an returns no values. Supported parameter types: int, uint, long, ulong, float, double public static HostFunction FromMethod<I1, I2>(string functionName, object userData, Action<CurrentPlugin, I1, I2> callback) where I1 : struct where I2 : struct Parameters functionName string The literal name of the function, how it would be called from a Plugin. userData object A state object that will be preserved and can be retrieved during function execution using GetUserData<T>(). This allows you to maintain context between function calls. callback Action<CurrentPlugin, I1, I2> The host function implementation. Returns HostFunction Type Parameters I1 Type of the first parameter. Supported parameter types: int, uint, long, ulong, float, double I2 Type of the second parameter. Supported parameter types: int, uint, long, ulong, float, double FromMethod<I1, R>(string, object, Func<CurrentPlugin, I1, R>) Registers a HostFunction from a method that takes 1 parameter an returns a value. Supported return and parameter types: int, uint, long, ulong, float, double public static HostFunction FromMethod<I1, R>(string functionName, object userData, Func<CurrentPlugin, I1, R> callback) where I1 : struct where R : struct Parameters functionName string The literal name of the function, how it would be called from a Plugin. userData object A state object that will be preserved and can be retrieved during function execution using GetUserData<T>(). This allows you to maintain context between function calls. callback Func<CurrentPlugin, I1, R> The host function implementation. Returns HostFunction Type Parameters I1 Type of the first parameter. Supported parameter types: int, uint, long, ulong, float, double R Type of the first parameter. Supported parameter types: int, uint, long, ulong, float, double FromMethod<I1, I2, I3>(string, object, Action<CurrentPlugin, I1, I2, I3>) Registers a HostFunction from a method that takes 3 parameters an returns no values. Supported parameter types: int, uint, long, ulong, float, double public static HostFunction FromMethod<I1, I2, I3>(string functionName, object userData, Action<CurrentPlugin, I1, I2, I3> callback) where I1 : struct where I2 : struct where I3 : struct Parameters functionName string The literal name of the function, how it would be called from a Plugin. userData object A state object that will be preserved and can be retrieved during function execution using GetUserData<T>(). This allows you to maintain context between function calls. callback Action<CurrentPlugin, I1, I2, I3> The host function implementation. Returns HostFunction Type Parameters I1 Type of the first parameter. Supported parameter types: int, uint, long, ulong, float, double I2 Type of the second parameter. Supported parameter types: int, uint, long, ulong, float, double I3 Type of the third parameter. Supported parameter types: int, uint, long, ulong, float, double FromMethod<I1, I2, R>(string, object, Func<CurrentPlugin, I1, I2, R>) Registers a HostFunction from a method that takes 2 parameter an returns a value. Supported return and parameter types: int, uint, long, ulong, float, double public static HostFunction FromMethod<I1, I2, R>(string functionName, object userData, Func<CurrentPlugin, I1, I2, R> callback) where I1 : struct where I2 : struct where R : struct Parameters functionName string The literal name of the function, how it would be called from a Plugin. userData object A state object that will be preserved and can be retrieved during function execution using GetUserData<T>(). This allows you to maintain context between function calls. callback Func<CurrentPlugin, I1, I2, R> The host function implementation. Returns HostFunction Type Parameters I1 Type of the first parameter. Supported parameter types: int, uint, long, ulong, float, double I2 Type of the second parameter. Supported parameter types: int, uint, long, ulong, float, double R Type of the first parameter. Supported parameter types: int, uint, long, ulong, float, double FromMethod<I1, I2, I3, R>(string, object, Func<CurrentPlugin, I1, I2, I3, R>) Registers a HostFunction from a method that takes 3 parameter an returns a value. Supported return and parameter types: int, uint, long, ulong, float, double public static HostFunction FromMethod<I1, I2, I3, R>(string functionName, object userData, Func<CurrentPlugin, I1, I2, I3, R> callback) where I1 : struct where I2 : struct where I3 : struct where R : struct Parameters functionName string The literal name of the function, how it would be called from a Plugin. userData object A state object that will be preserved and can be retrieved during function execution using GetUserData<T>(). This allows you to maintain context between function calls. callback Func<CurrentPlugin, I1, I2, I3, R> The host function implementation. Returns HostFunction Type Parameters I1 Type of the first parameter. Supported parameter types: int, uint, long, ulong, float, double I2 Type of the second parameter. Supported parameter types: int, uint, long, ulong, float, double I3 Type of the third parameter. Supported parameter types: int, uint, long, ulong, float, double R Type of the first parameter. Supported parameter types: int, uint, long, ulong, float, double SetNamespace(string) Sets the function namespace. By default it's set to env. public void SetNamespace(string ns) Parameters ns string WithNamespace(string) Sets the function namespace. By default it's set to extism:host/user. public HostFunction WithNamespace(string ns) Parameters ns string Returns HostFunction"
  },
  "api/Extism.Sdk.HttpMethod.html": {
    "href": "api/Extism.Sdk.HttpMethod.html",
    "title": "Enum HttpMethod | Extism .NET SDK",
    "summary": "Enum HttpMethod Namespace Extism.Sdk Assembly Extism.Sdk.dll HTTP defines a set of request methods to indicate the desired action to be performed for a given resource. public enum HttpMethod Fields CONNECT = 5 The CONNECT method establishes a tunnel to the server identified by the target resource. DELETE = 4 The DELETE method deletes the specified resource. GET = 0 The GET method requests a representation of the specified resource. Requests using GET should only retrieve data. HEAD = 1 The HEAD method asks for a response identical to a GET request, but without the response body. OPTIONS = 6 The OPTIONS method describes the communication options for the target resource. PATCH = 8 The PATCH method applies partial modifications to a resource. POST = 2 The POST method submits an entity to the specified resource, often causing a change in state or side effects on the server. PUT = 3 The PUT method replaces all current representations of the target resource with the request payload. TRACE = 7 The TRACE method performs a message loop-back test along the path to the target resource."
  },
  "api/Extism.Sdk.LogLevel.html": {
    "href": "api/Extism.Sdk.LogLevel.html",
    "title": "Enum LogLevel | Extism .NET SDK",
    "summary": "Enum LogLevel Namespace Extism.Sdk Assembly Extism.Sdk.dll Extism Log Levels public enum LogLevel Fields Debug = 4 Designates lower priority information. Error = 1 Designates very serious errors. Info = 3 Designates useful information. Trace = 5 Designates very low priority, often extremely verbose, information. Warn = 2 Designates hazardous situations."
  },
  "api/Extism.Sdk.LoggingSink.html": {
    "href": "api/Extism.Sdk.LoggingSink.html",
    "title": "Delegate LoggingSink | Extism .NET SDK",
    "summary": "Delegate LoggingSink Namespace Extism.Sdk Assembly Extism.Sdk.dll Custom logging callback. public delegate void LoggingSink(string line) Parameters line string"
  },
  "api/Extism.Sdk.Manifest.html": {
    "href": "api/Extism.Sdk.Manifest.html",
    "title": "Class Manifest | Extism .NET SDK",
    "summary": "Class Manifest Namespace Extism.Sdk Assembly Extism.Sdk.dll The manifest is a description of your plugin and some of the runtime constraints to apply to it. You can think of it as a blueprint to build your plugin. public class Manifest Inheritance object Manifest Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors Manifest() Create an empty manifest. public Manifest() Manifest(params WasmSource[]) Create a manifest from one or more Wasm sources. public Manifest(params WasmSource[] sources) Parameters sources WasmSource[] Properties AllowedHosts List of host names the plugins can access. Example: AllowedHosts = new List<string> { \"www.example.com\", \"api.*.com\", \"example.*\", } [JsonPropertyName(\"allowed_hosts\")] public IList<string> AllowedHosts { get; set; } Property Value IList<string> AllowedPaths List of directories that can be accessed by the plugins. Examples: AllowedPaths = new Dictionary<string, string> { { \"/usr/plugins/1/data\", \"/data\" }, // src, dest { \"d:/plugins/1/data\", \"/data\" } // src, dest }; [JsonPropertyName(\"allowed_paths\")] public IDictionary<string, string> AllowedPaths { get; set; } Property Value IDictionary<string, string> Config Configurations available to the plugins. Examples: Config = new Dictionary<string, string> { { \"userId\", \"55\" }, // key, value { \"mySecret\", \"super-secret-key\" } // key, value }; [JsonPropertyName(\"config\")] public IDictionary<string, string> Config { get; set; } Property Value IDictionary<string, string> MemoryOptions Configures memory for the Wasm runtime. Memory is described in units of pages (64KB) and represent contiguous chunks of addressable memory. [JsonPropertyName(\"memory\")] public MemoryOptions? MemoryOptions { get; set; } Property Value MemoryOptions Sources List of Wasm sources. See PathWasmSource and ByteArrayWasmSource. [JsonPropertyName(\"wasm\")] public IList<WasmSource> Sources { get; set; } Property Value IList<WasmSource> Timeout Plugin call timeout. [JsonPropertyName(\"timeout_ms\")] [JsonConverter(typeof(TimeSpanMillisecondsConverter))] public TimeSpan? Timeout { get; set; } Property Value TimeSpan?"
  },
  "api/Extism.Sdk.MemoryOptions.html": {
    "href": "api/Extism.Sdk.MemoryOptions.html",
    "title": "Class MemoryOptions | Extism .NET SDK",
    "summary": "Class MemoryOptions Namespace Extism.Sdk Assembly Extism.Sdk.dll Configures memory for the Wasm runtime. Memory is described in units of pages (64KB) and represent contiguous chunks of addressable memory. public class MemoryOptions Inheritance object MemoryOptions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties MaxHttpResponseBytes Max number of bytes allowed in an HTTP response when using extism_http_request. [JsonPropertyName(\"max_http_response_bytes\")] public int MaxHttpResponseBytes { get; set; } Property Value int MaxPages Max number of pages. Each page is 64KB. [JsonPropertyName(\"max_pages\")] public int MaxPages { get; set; } Property Value int MaxVarBytes Max number of bytes allowed in the Extism var store [JsonPropertyName(\"max_var_bytes\")] public int MaxVarBytes { get; set; } Property Value int"
  },
  "api/Extism.Sdk.Native.ExtismVal.html": {
    "href": "api/Extism.Sdk.Native.ExtismVal.html",
    "title": "Struct ExtismVal | Extism .NET SDK",
    "summary": "Struct ExtismVal Namespace Extism.Sdk.Native Assembly Extism.Sdk.dll ExtismVal holds the type and value of a function argument/return public struct ExtismVal Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields t The type for the argument public ExtismValType t Field Value ExtismValType v The value for the argument public ExtismValUnion v Field Value ExtismValUnion"
  },
  "api/Extism.Sdk.Native.ExtismValType.html": {
    "href": "api/Extism.Sdk.Native.ExtismValType.html",
    "title": "Enum ExtismValType | Extism .NET SDK",
    "summary": "Enum ExtismValType Namespace Extism.Sdk.Native Assembly Extism.Sdk.dll Represents Wasm data types that Extism can understand public enum ExtismValType Fields ExternRef = 6 A reference to opaque data in the Wasm instance. F32 = 2 Floating point 32 bit integer. Equivalent of float F64 = 3 Floating point 64 bit integer. Equivalent of double FuncRef = 5 A reference to opaque data in the Wasm instance. I32 = 0 Signed 32 bit integer. Equivalent of int or uint I64 = 1 Signed 64 bit integer. Equivalent of long or long PTR = 1 A wrapper around I64 to specify arguments that are pointers to memory blocks V128 = 4 A 128 bit number."
  },
  "api/Extism.Sdk.Native.ExtismValUnion.html": {
    "href": "api/Extism.Sdk.Native.ExtismValUnion.html",
    "title": "Struct ExtismValUnion | Extism .NET SDK",
    "summary": "Struct ExtismValUnion Namespace Extism.Sdk.Native Assembly Extism.Sdk.dll A union type for host function argument/return values. public struct ExtismValUnion Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Fields f32 Set this for 32 bit floats public float f32 Field Value float f64 Set this for 64 bit floats public double f64 Field Value double i32 Set this for 32 bit integers public int i32 Field Value int i64 Set this for 64 bit integers public long i64 Field Value long ptr Set this for 64 bit integers public long ptr Field Value long"
  },
  "api/Extism.Sdk.Native.html": {
    "href": "api/Extism.Sdk.Native.html",
    "title": "Namespace Extism.Sdk.Native | Extism .NET SDK",
    "summary": "Namespace Extism.Sdk.Native Structs ExtismVal ExtismVal holds the type and value of a function argument/return ExtismValUnion A union type for host function argument/return values. Enums ExtismValType Represents Wasm data types that Extism can understand"
  },
  "api/Extism.Sdk.PathWasmSource.html": {
    "href": "api/Extism.Sdk.PathWasmSource.html",
    "title": "Class PathWasmSource | Extism .NET SDK",
    "summary": "Class PathWasmSource Namespace Extism.Sdk Assembly Extism.Sdk.dll Wasm Source represented by a file referenced by a path. public class PathWasmSource : WasmSource Inheritance object WasmSource PathWasmSource Inherited Members WasmSource.Name WasmSource.Hash object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors PathWasmSource(string, string?, string?) Constructor public PathWasmSource(string path, string? name = null, string? hash = null) Parameters path string path to wasm plugin. name string hash string Properties Path Path to wasm plugin. [JsonPropertyName(\"path\")] public string Path { get; set; } Property Value string"
  },
  "api/Extism.Sdk.Plugin.html": {
    "href": "api/Extism.Sdk.Plugin.html",
    "title": "Class Plugin | Extism .NET SDK",
    "summary": "Class Plugin Namespace Extism.Sdk Assembly Extism.Sdk.dll Represents a WASM Extism plugin. public class Plugin : IDisposable Inheritance object Plugin Implements IDisposable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors Plugin(Manifest, HostFunction[], PluginIntializationOptions) Initialize a plugin from a Manifest. public Plugin(Manifest manifest, HostFunction[] functions, PluginIntializationOptions options) Parameters manifest Manifest functions HostFunction[] options PluginIntializationOptions Plugin(Manifest, HostFunction[], bool) Create a plugin from a Manifest. public Plugin(Manifest manifest, HostFunction[] functions, bool withWasi) Parameters manifest Manifest functions HostFunction[] withWasi bool Plugin(ReadOnlySpan<byte>, HostFunction[], bool) Create and load a plugin from a byte array. public Plugin(ReadOnlySpan<byte> wasm, HostFunction[] functions, bool withWasi) Parameters wasm ReadOnlySpan<byte> A WASM module (wat or wasm) or a JSON encoded manifest. functions HostFunction[] List of host functions expected by the plugin. withWasi bool Enable/Disable WASI. Properties Id Get the plugin's ID. public Guid Id { get; } Property Value Guid Methods AllowHttpResponseHeaders() Enable HTTP response headers in plugins using extism:host/env::http_request public void AllowHttpResponseHeaders() Call(string, ReadOnlySpan<byte>, CancellationToken?) Calls a function in the current plugin and returns the output as a byte buffer. public ReadOnlySpan<byte> Call(string functionName, ReadOnlySpan<byte> input, CancellationToken? cancellationToken = null) Parameters functionName string Name of the function in the plugin to invoke. input ReadOnlySpan<byte> A buffer to provide as input to the function. cancellationToken CancellationToken? CancellationToken used for cancelling the Extism call. Returns ReadOnlySpan<byte> The output of the function call Exceptions ExtismException Call(string, string, CancellationToken?) Calls a function in the current plugin and returns the output as a UTF8 encoded string. public string Call(string functionName, string input, CancellationToken? cancellationToken = null) Parameters functionName string Name of the function in the plugin to invoke. input string A string that will be UTF8 encoded and passed to the plugin. cancellationToken CancellationToken? CancellationToken used for cancelling the Extism call. Returns string The output of the function as a UTF8 encoded string CallWithHostContext<T>(string, ReadOnlySpan<byte>, T, CancellationToken?) Calls a function in the current plugin and returns the output as a byte buffer. public ReadOnlySpan<byte> CallWithHostContext<T>(string functionName, ReadOnlySpan<byte> input, T hostContext, CancellationToken? cancellationToken = null) Parameters functionName string Name of the function in the plugin to invoke. input ReadOnlySpan<byte> A buffer to provide as input to the function. hostContext T An object that will be passed back to HostFunctions cancellationToken CancellationToken? CancellationToken used for cancelling the Extism call. Returns ReadOnlySpan<byte> The output of the function call Type Parameters T Exceptions ExtismException Call<TOutput>(string, string, JsonSerializerOptions?, CancellationToken?) Calls a function on the plugin and deserializes the output as UTF8 encoded JSON. public TOutput? Call<TOutput>(string functionName, string input, JsonSerializerOptions? serializerOptions = null, CancellationToken? cancellationToken = null) Parameters functionName string Name of the function in the plugin to invoke. input string Function input. serializerOptions JsonSerializerOptions JSON serialization options used for serialization/derserialization. cancellationToken CancellationToken? CancellationToken used for cancelling the Extism call. Returns TOutput Type Parameters TOutput Type of the output payload returned by the function. Call<TOutput>(string, string, JsonTypeInfo<TOutput?>, CancellationToken?) Calls a function on the plugin with a payload. The payload is serialized into JSON and encoded in UTF8. public TOutput? Call<TOutput>(string functionName, string input, JsonTypeInfo<TOutput?> outputJsonInfo, CancellationToken? cancellationToken = null) Parameters functionName string Name of the function in the plugin to invoke. input string Function input. outputJsonInfo JsonTypeInfo<TOutput> Metadata about output type. cancellationToken CancellationToken? CancellationToken used for cancelling the Extism call. Returns TOutput Type Parameters TOutput Type of the output payload returned by the function. Call<TInput, TOutput>(string, TInput, JsonSerializerOptions?, CancellationToken?) Calls a function on the plugin with a payload. The payload is serialized into JSON and encoded in UTF8. public TOutput? Call<TInput, TOutput>(string functionName, TInput input, JsonSerializerOptions? serializerOptions = null, CancellationToken? cancellationToken = null) Parameters functionName string Name of the function in the plugin to invoke. input TInput An object that will be serialized into JSON and passed into the function as a UTF8 encoded string. serializerOptions JsonSerializerOptions JSON serialization options used for serialization/derserialization cancellationToken CancellationToken? CancellationToken used for cancelling the Extism call. Returns TOutput Type Parameters TInput Type of the input payload. TOutput Type of the output payload returned by the function. Call<TInput, TOutput>(string, TInput, JsonTypeInfo<TInput>, JsonTypeInfo<TOutput?>, CancellationToken?) Calls a function on the plugin with a payload. The payload is serialized into JSON and encoded in UTF8. public TOutput? Call<TInput, TOutput>(string functionName, TInput input, JsonTypeInfo<TInput> inputJsonInfo, JsonTypeInfo<TOutput?> outputJsonInfo, CancellationToken? cancellationToken = null) Parameters functionName string Name of the function in the plugin to invoke. input TInput An object that will be serialized into JSON and passed into the function as a UTF8 encoded string. inputJsonInfo JsonTypeInfo<TInput> Metadata about input type. outputJsonInfo JsonTypeInfo<TOutput> Metadata about output type. cancellationToken CancellationToken? CancellationToken used for cancelling the Extism call. Returns TOutput Type Parameters TInput Type of the input payload. TOutput Type of the output payload returned by the function. CheckNotDisposed() Throw an appropriate exception if the plugin has been disposed. protected void CheckNotDisposed() Exceptions ObjectDisposedException ConfigureCustomLogging(LogLevel) Enable a custom log handler, this will buffer logs until DrainCustomLogs(LoggingSink) is called. public static void ConfigureCustomLogging(LogLevel level) Parameters level LogLevel ConfigureFileLogging(string, LogLevel) Set log file and level public static void ConfigureFileLogging(string path, LogLevel level) Parameters path string Log file path level LogLevel Minimum log level Dispose() Frees all resources held by this Plugin. public void Dispose() Dispose(bool) Frees all resources held by this Plugin. protected virtual void Dispose(bool disposing) Parameters disposing bool DrainCustomLogs(LoggingSink) Calls the provided callback function for each buffered log line. This only needed when ConfigureCustomLogging(LogLevel) is used. public static void DrainCustomLogs(LoggingSink callback) Parameters callback LoggingSink ExtismVersion() Get Extism Runtime version. public static string ExtismVersion() Returns string ~Plugin() Destructs the current Plugin and frees all resources used by it. protected ~Plugin() FunctionExists(string) Checks if a specific function exists in the current plugin. public bool FunctionExists(string name) Parameters name string Returns bool Reset() Reset the Extism runtime, this will invalidate all allocated memory public bool Reset() Returns bool UpdateConfig(Dictionary<string, string>, JsonSerializerOptions) Update plugin config values, this will merge with the existing values. public bool UpdateConfig(Dictionary<string, string> value, JsonSerializerOptions serializerOptions) Parameters value Dictionary<string, string> serializerOptions JsonSerializerOptions Returns bool UpdateConfig(ReadOnlySpan<byte>) Update plugin config values, this will merge with the existing values. public bool UpdateConfig(ReadOnlySpan<byte> json) Parameters json ReadOnlySpan<byte> The configuration JSON encoded in UTF8. Returns bool"
  },
  "api/Extism.Sdk.PluginIntializationOptions.html": {
    "href": "api/Extism.Sdk.PluginIntializationOptions.html",
    "title": "Class PluginIntializationOptions | Extism .NET SDK",
    "summary": "Class PluginIntializationOptions Namespace Extism.Sdk Assembly Extism.Sdk.dll Options for initializing a plugin. public class PluginIntializationOptions Inheritance object PluginIntializationOptions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties FuelLimit Limits number of instructions that can be executed by the plugin. public long? FuelLimit { get; set; } Property Value long? WithWasi Enable WASI support. public bool WithWasi { get; set; } Property Value bool"
  },
  "api/Extism.Sdk.UrlWasmSource.html": {
    "href": "api/Extism.Sdk.UrlWasmSource.html",
    "title": "Class UrlWasmSource | Extism .NET SDK",
    "summary": "Class UrlWasmSource Namespace Extism.Sdk Assembly Extism.Sdk.dll Wasm Source represented by a file referenced by a path. public class UrlWasmSource : WasmSource Inheritance object WasmSource UrlWasmSource Inherited Members WasmSource.Name WasmSource.Hash object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors UrlWasmSource(string, string?, string?) Constructor public UrlWasmSource(string url, string? name = null, string? hash = null) Parameters url string uri to wasm plugin. name string hash string UrlWasmSource(Uri, string?, string?) Constructor public UrlWasmSource(Uri url, string? name = null, string? hash = null) Parameters url Uri uri to wasm plugin. name string hash string Properties Headers HTTP headers [JsonPropertyName(\"headers\")] public Dictionary<string, string> Headers { get; set; } Property Value Dictionary<string, string> Method HTTP Method [JsonPropertyName(\"method\")] public HttpMethod? Method { get; set; } Property Value HttpMethod? Url Uri to wasm plugin. [JsonPropertyName(\"url\")] public Uri Url { get; set; } Property Value Uri"
  },
  "api/Extism.Sdk.WasmSource.html": {
    "href": "api/Extism.Sdk.WasmSource.html",
    "title": "Class WasmSource | Extism .NET SDK",
    "summary": "Class WasmSource Namespace Extism.Sdk Assembly Extism.Sdk.dll A named Wasm source. public abstract class WasmSource Inheritance object WasmSource Derived ByteArrayWasmSource PathWasmSource UrlWasmSource Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Hash Hash of the WASM source [JsonPropertyName(\"hash\")] public string? Hash { get; set; } Property Value string Name Logical name of the Wasm source [JsonPropertyName(\"name\")] public string? Name { get; set; } Property Value string"
  },
  "api/Extism.Sdk.html": {
    "href": "api/Extism.Sdk.html",
    "title": "Namespace Extism.Sdk | Extism .NET SDK",
    "summary": "Namespace Extism.Sdk Classes ByteArrayWasmSource Wasm Source represented by raw bytes. CompiledPlugin A pre-compiled plugin ready to be instantiated. CurrentPlugin Represents the current plugin. Can only be used within HostFunctions. ExtismException Represents errors that occur during calling Extism functions. HostFunction A function provided by the host that plugins can call. Manifest The manifest is a description of your plugin and some of the runtime constraints to apply to it. You can think of it as a blueprint to build your plugin. MemoryOptions Configures memory for the Wasm runtime. Memory is described in units of pages (64KB) and represent contiguous chunks of addressable memory. PathWasmSource Wasm Source represented by a file referenced by a path. Plugin Represents a WASM Extism plugin. PluginIntializationOptions Options for initializing a plugin. UrlWasmSource Wasm Source represented by a file referenced by a path. WasmSource A named Wasm source. Enums HttpMethod HTTP defines a set of request methods to indicate the desired action to be performed for a given resource. LogLevel Extism Log Levels Delegates ExtismFunction A host function signature. LoggingSink Custom logging callback."
  },
  "index.html": {
    "href": "index.html",
    "title": "Extism .NET Host SDK | Extism .NET SDK",
    "summary": "Extism .NET Host SDK This repo houses the .NET SDK for integrating with the Extism runtime. Install this library into your host .NET applications to run Extism plugins. Installation This library depends on the native Extism runtime, we provide native runtime packages for all supported operating systems. You can install with: dotnet add package Extism.runtime.all Then, add the Extism.Sdk NuGet package to your project: dotnet add package Extism.Sdk PowerShell Open a PowerShell console and detect the Common Language Runtime (CLR) major version with the command [System.Environment]::Version Download the Extism.Sdk NuGet package and change the extension from nupkg to zip. Open the zip file and go into the lib folder. Choose the net folder in dependency of the CLR major version and open it. Copy the file Extism.sdk.dll in your PowerShell script directory. Download the Extism native runtime package in dependency of your operating system and change the extension from nupkg to zip. Open the zip file and go into the runtimes folder. At the end of the path you will find a file with the name libextism.so (shared object) or extism.dll (dynamic link library). Copy this file in your PowerShell script directory. Getting Started This guide should walk you through some of the concepts in Extism and this .NET library. First you should add a using statement for Extism: C#: using System; using Extism.Sdk; F#: open System open Extism.Sdk PowerShell [System.String]$LibDir = $($PSScriptRoot) [System.String]$Extism = $($LibDir) + \"/Extism.Sdk.dll\" Add-Type -Path $Extism Creating A Plug-in The primary concept in Extism is the plug-in. You can think of a plug-in as a code module stored in a .wasm file. Since you may not have an Extism plug-in on hand to test, let's load a demo plug-in from the web: C#: var manifest = new Manifest(new UrlWasmSource(\"https://github.com/extism/plugins/releases/latest/download/count_vowels.wasm\")); using var plugin = new Plugin(manifest, new HostFunction[] { }, withWasi: true); F#: let uri = Uri(\"https://github.com/extism/plugins/releases/latest/download/count_vowels.wasm\") let manifest = Manifest(new UrlWasmSource(uri)) let plugin = new Plugin(manifest, Array.Empty<HostFunction>(), withWasi = true) PowerShell: $Manifest = [Extism.Sdk.Manifest]::new( [Extism.Sdk.UrlWasmSource]::new( \"https://github.com/extism/plugins/releases/latest/download/count_vowels.wasm\" ) ) $HostFunctionArray = [Extism.Sdk.HostFunction[]]::new(0) $Options = [Extism.Sdk.PluginIntializationOptions]::new() $Options.WithWasi = $True $Plugin = [Extism.Sdk.Plugin]::new($Manifest, $HostFunctionArray, $Options) Note: The schema for this manifest can be found here: https://extism.org/docs/concepts/manifest/ Calling A Plug-in's Exports This plug-in was written in Rust and it does one thing, it counts vowels in a string. As such, it exposes one \"export\" function: count_vowels. We can call exports using Plugin.Call: C#: var output = plugin.Call(\"count_vowels\", \"Hello, World!\"); Console.WriteLine(output); // => {\"count\": 3, \"total\": 3, \"vowels\": \"aeiouAEIOU\"} F#: let output = plugin.Call(\"count_vowels\", \"Hello, World!\") printfn \"%s\" output // => {\"count\": 3, \"total\": 3, \"vowels\": \"aeiouAEIOU\"} PowerShell: $output = $Plugin.Call(\"count_vowels\", \"Hello, World!\") Write-Host $output # => {\"count\": 3, \"total\": 3, \"vowels\": \"aeiouAEIOU\"} All exports have a simple interface of optional bytes in, and optional bytes out. This plug-in happens to take a string and return a JSON encoded string with a report of results. Precompiling plugins If you're going to create more than one instance of the same plugin, we recommend pre-compiling the plugin and instantiate them: C#: var manifest = new Manifest(new PathWasmSource(\"/path/to/plugin.wasm\"), \"main\")); // pre-compile the wasm file using var compiledPlugin = new CompiledPlugin(_manifest, [], withWasi: true); // instantiate plugins using var plugin = compiledPlugin.Instantiate(); F#: // Create manifest let manifest = Manifest(PathWasmSource(\"/path/to/plugin.wasm\")) // Pre-compile the wasm file use compiledPlugin = new CompiledPlugin(manifest, Array.empty<HostFunction>, withWasi = true) // Instantiate plugins use plugin = compiledPlugin.Instantiate() This can have a dramatic effect on performance*: // * Summary * BenchmarkDotNet v0.14.0, Windows 11 (10.0.22631.4460/23H2/2023Update/SunValley3) 13th Gen Intel Core i7-1365U, 1 CPU, 12 logical and 10 physical cores .NET SDK 9.0.100 [Host] : .NET 9.0.0 (9.0.24.52809), X64 RyuJIT AVX2 DefaultJob : .NET 9.0.0 (9.0.24.52809), X64 RyuJIT AVX2 | Method | Mean | Error | StdDev | |-------------------------- |------------:|----------:|------------:| | CompiledPluginInstantiate | 266.2 ms | 6.66 ms | 19.11 ms | | PluginInstantiate | 27,592.4 ms | 635.90 ms | 1,783.12 ms | *: See the complete benchmark Plug-in State Plug-ins may be stateful or stateless. Plug-ins can maintain state b/w calls by the use of variables. Our count vowels plug-in remembers the total number of vowels it's ever counted in the \"total\" key in the result. You can see this by making subsequent calls to the export: C#: var output = plugin.Call(\"count_vowels\", \"Hello, World!\"); Console.WriteLine(output); // => {\"count\": 3, \"total\": 6, \"vowels\": \"aeiouAEIOU\"} output = plugin.Call(\"count_vowels\", \"Hello, World!\"); Console.WriteLine(output); // => {\"count\": 3, \"total\": 9, \"vowels\": \"aeiouAEIOU\"} F#: let output1 = plugin.Call(\"count_vowels\", \"Hello, World!\") printfn \"%s\" output1 // => {\"count\": 3, \"total\": 6, \"vowels\": \"aeiouAEIOU\"} let output2 = plugin.Call(\"count_vowels\", \"Hello, World!\") printfn \"%s\" output2 // => {\"count\": 3, \"total\": 9, \"vowels\": \"aeiouAEIOU\"} These variables will persist until this plug-in is freed or you initialize a new one. Configuration Plug-ins may optionally take a configuration object. This is a static way to configure the plug-in. Our count-vowels plugin takes an optional configuration to change out which characters are considered vowels. Example: C#: var manifest = new Manifest(new UrlWasmSource(\"<https://github.com/extism/plugins/releases/latest/download/count_vowels.wasm>\")); using var plugin = new Plugin(manifest, new HostFunction[] { }, withWasi: true); var output = plugin.Call(\"count_vowels\", \"Yellow, World!\"); Console.WriteLine(output); // => {\"count\": 3, \"total\": 3, \"vowels\": \"aeiouAEIOU\"} manifest = new Manifest(new UrlWasmSource(\"<https://github.com/extism/plugins/releases/latest/download/count_vowels.wasm>\")) { Config = new Dictionary<string, string> { { \"vowels\", \"aeiouyAEIOUY\" } }, }; using var plugin2 = new Plugin(manifest, new HostFunction[] { }, withWasi: true); var output2 = plugin2.Call(\"count_vowels\", \"Yellow, World!\"); Console.WriteLine(output2); // => {\"count\": 4, \"total\": 4, \"vowels\": \"aeiouAEIOUY\"} F#: let uri = Uri(\"https://github.com/extism/plugins/releases/latest/download/count_vowels.wasm\") let manifest = Manifest(new UrlWasmSource(uri)) manifest.Config <- dict [(\"vowels\", \"aeiouAEIOU\")] let plugin = new Plugin(manifest, Array.Empty<HostFunction>(), withWasi = true) let output = plugin.Call(\"count_vowels\", \"Yellow, World!\") Console.WriteLine(output) // => {\"count\": 3, \"total\": 3, \"vowels\": \"aeiouAEIOU\"} let manifest2 = Manifest(new UrlWasmSource(Uri(\"https://github.com/extism/plugins/releases/latest/download/count_vowels.wasm\"))) manifest2.Config <- dict [(\"vowels\", \"aeiouyAEIOUY\")] let plugin2 = new Plugin(manifest2, Array.Empty<HostFunction>(), withWasi = true) let output2 = plugin2.Call(\"count_vowels\", \"Yellow, World!\") printfn \"%s\" output2 // => {\"count\": 4, \"total\": 4, \"vowels\": \"aeiouAEIOUY\"} Host Functions Let's extend our count-vowels example a little bit: Instead of storing the total in an ephemeral plug-in var, let's store it in a persistent key-value store! Wasm can't use our KV store on it's own. This is where Host Functions come in. Host functions allow us to grant new capabilities to our plug-ins from our application. They are simply some Go functions you write which can be passed down and invoked from any language inside the plug-in. Let's load the manifest like usual but load up this count_vowels_kvstore plug-in: C#: var manifest = new Manifest(new UrlWasmSource(\"https://github.com/extism/plugins/releases/latest/download/count_vowels_kvstore.wasm\")); F#: let manifest = Manifest(new UrlWasmSource(Uri(\"https://github.com/extism/plugins/releases/latest/download/count_vowels_kvstore.wasm\"))) Note: The source code for this is here and is written in rust, but it could be written in any of our PDK languages. Unlike our previous plug-in, this plug-in expects you to provide host functions that satisfy our its import interface for a KV store. We want to expose two functions to our plugin, void kv_write(key string, value byte[]) which writes a bytes value to a key and byte[] kv_read(key string) which reads the bytes at the given key. C#: // pretend this is Redis or something :) var kvStore = new Dictionary<string, byte[]>(); var functions = new[] { HostFunction.FromMethod(\"kv_read\", null, (CurrentPlugin plugin, long keyOffset) => { var key = plugin.ReadString(keyOffset); if (!kvStore.TryGetValue(key, out var value)) { value = new byte[] { 0, 0, 0, 0 }; } Console.WriteLine($\"Read {BitConverter.ToUInt32(value)} from key={key}\"); return plugin.WriteBytes(value); }), HostFunction.FromMethod(\"kv_write\", null, (CurrentPlugin plugin, long keyOffset, long valueOffset) => { var key = plugin.ReadString(keyOffset); var value = plugin.ReadBytes(valueOffset); Console.WriteLine($\"Writing value={BitConverter.ToUInt32(value)} from key={key}\"); kvStore[key] = value.ToArray(); }) }; F#: let kvStore = new Dictionary<string, byte[]>() let functions = [| HostFunction.FromMethod(\"kv_read\", null, fun (plugin: CurrentPlugin) (offs: int64) -> let key = plugin.ReadString(offs) let value = match kvStore.TryGetValue(key) with | true, v -> v | _ -> [| 0uy; 0uy; 0uy; 0uy |] // Default value if key not found Console.WriteLine($\"Read {BitConverter.ToUInt32(value, 0)} from key={key}\") plugin.WriteBytes(value) ) HostFunction.FromMethod(\"kv_write\", null, fun (plugin: CurrentPlugin) (kOffs: int64) (vOffs: int64) -> let key = plugin.ReadString(kOffs) let value = plugin.ReadBytes(vOffs).ToArray() Console.WriteLine($\"Writing value={BitConverter.ToUInt32(value, 0)} from key={key}\") kvStore.[key] <- value ) |] Note: In order to write host functions you should get familiar with the methods on the CurrentPlugin type. The plugin parameter is an instance of this type. We need to pass these imports to the plug-in to create them. All imports of a plug-in must be satisfied for it to be initialized: C#: using var plugin = new Plugin(manifest, functions, withWasi: true); var output = plugin.Call(\"count_vowels\", \"Hello World!\"); Console.WriteLine(output); // => Read 0 from key=count-vowels\" // => Writing value=3 from key=count-vowels\" // => {\"count\": 3, \"total\": 3, \"vowels\": \"aeiouAEIOU\"} output = plugin.Call(\"count_vowels\", \"Hello World!\"); Console.WriteLine(output); // => Read 3 from key=count-vowels\" // => Writing value=6 from key=count-vowels\" // => {\"count\": 3, \"total\": 6, \"vowels\": \"aeiouAEIOU\"} F#: let plugin = new Plugin(manifest, functions, withWasi = true) let output = plugin.Call(\"count_vowels\", \"Hello World!\") printfn \"%s\" output // => Read 0 from key=count-vowels // => Writing value=3 from key=count-vowels // => {\"count\": 3, \"total\": 3, \"vowels\": \"aeiouAEIOU\"} let output2 = plugin.Call(\"count_vowels\", \"Hello World!\") printfn \"%s\" output2 // => Read 3 from key=count-vowels // => Writing value=6 from key=count-vowels // => {\"count\": 3, \"total\": 6, \"vowels\": \"aeiouAEIOU\"} Passing context to host functions Extism provides two ways to pass context to host functions: UserData UserData allows you to associate persistent state with a host function that remains available across all calls to that function. This is useful for maintaining configuration or state that should be available throughout the lifetime of the host function. C#: var hostFunc = new HostFunction( \"hello_world\", new[] { ExtismValType.PTR }, new[] { ExtismValType.PTR }, \"Hello again!\", // <= userData, this can be any .NET object (CurrentPlugin plugin, Span<ExtismVal> inputs, Span<ExtismVal> outputs) => { var text = plugin.GetUserData<string>(); // <= We're retrieving the data back // Use text... }); F#: // Create host function with userData let hostFunc = new HostFunction( \"hello_world\", [| ExtismValType.PTR |], [| ExtismValType.PTR |], \"Hello again!\", // userData can be any .NET object (fun (plugin: CurrentPlugin) (inputs: Span<ExtismVal>) (outputs: Span<ExtismVal>) -> // Retrieve the userData let text = plugin.GetUserData<string>() printfn \"%s\" text // Prints: \"Hello again!\" // Rest of function implementation... )) The userData object is preserved for the lifetime of the host function and can be retrieved in any call using CurrentPlugin.GetUserData<T>(). If no userData was provided, GetUserData<T>() will return the default value for type T. Call Host Context Call Host Context provides a way to pass per-call context data when invoking a plugin function. This is useful when you need to provide data specific to a particular function call rather than data that persists across all calls. C#: // Pass context for specific call var context = new Dictionary<string, object> { { \"requestId\", 42 } }; var result = plugin.CallWithHostContext(\"function_name\", inputData, context); // Access in host function void HostFunction(CurrentPlugin plugin, Span<ExtismVal> inputs, Span<ExtismVal> outputs) { var context = plugin.GetCallHostContext<Dictionary<string, object>>(); // Use context... } F#: // Create context for specific call let context = dict [ \"requestId\", box 42 ] // Call plugin with context let result = plugin.CallWithHostContext(\"function_name\", inputData, context) // Access context in host function let hostFunction (plugin: CurrentPlugin) (inputs: Span<ExtismVal>) (outputs: Span<ExtismVal>) = match plugin.GetCallHostContext<IDictionary<string, obj>>() with | null -> printfn \"No context available\" | context -> let requestId = context.[\"requestId\"] :?> int printfn \"Request ID: %d\" requestId Host context is only available for the duration of the specific function call and can be retrieved using CurrentPlugin.GetHostContext<T>(). If no context was provided for the call, GetHostContext<T>() will return the default value for type T. Fuel limit The fuel limit feature allows you to constrain plugin execution by limiting the number of instructions it can execute. This provides a safeguard against infinite loops or excessive resource consumption. Setting a fuel limit Set the fuel limit when initializing a plugin: C#: var manifest = new Manifest(...); var options = new PluginIntializationOptions { FuelLimit = 1000, // plugin can execute 1000 instructions WithWasi = true }; var plugin = new Plugin(manifest, functions, options); F#: let manifest = Manifest(PathWasmSource(\"/path/to/plugin.wasm\")) let options = PluginIntializationOptions( FuelLimit = Nullable<int64>(1000L), // plugin can execute 1000 instructions WithWasi = true ) use plugin = new Plugin(manifest, Array.empty<HostFunction>, options) When the fuel limit is exceeded, the plugin execution is terminated and an ExtismException is thrown containing \"fuel\" in the error message. API Docs Please see our API docs for detailed information on each type."
  },
  "samples/Extism.Sdk.Sample/README.html": {
    "href": "samples/Extism.Sdk.Sample/README.html",
    "title": "| Extism .NET SDK",
    "summary": "Example 1 This example shows how you can use the library in the most basic way. It loads up the sample wasm plugin and lets you to pass inputs to it and show the ouput."
  },
  "src/Extism.Sdk/README.html": {
    "href": "src/Extism.Sdk/README.html",
    "title": "| Extism .NET SDK",
    "summary": "Extism.Sdk Extism SDK that allows hosting Extism plugins in .NET apps."
  }
}